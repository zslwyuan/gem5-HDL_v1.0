#include "arch/locked_mem.hh"
#include "arch/mmapped_ipr.hh"
#include "arch/utility.hh"
#include "base/bigint.hh"
#include "config/the_isa.hh"

#include "cpu/fpgacpu/fpgacpu.hh"
#include "cpu/exetrace.hh"
#include "debug/Config.hh"
#include "debug/Drain.hh"
#include "debug/ExecFaulting.hh"
#include "debug/SimpleCPU.hh"
#include "mem/packet.hh"
#include "mem/packet_access.hh"
#include "params/FpgaCPU.hh"
#include "sim/faults.hh"
#include "sim/full_system.hh"
#include "sim/system.hh"
#include <iostream>
#include "debug/Mwait.hh"
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<limits.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<unistd.h>

#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<limits.h>
#include<sys/types.h>
#include<sys/stat.h>
#include <sys/shm.h>
#include "sim/sim_exit.hh"

using namespace std;
using namespace TheISA;

// following part is for pipe communication between two processes
// ------------------------------------------------------------------------------------


void FpgaCPU::createWrite()
{
	printf("111\n");
    if(access(FIFO_NAME_WRITE, F_OK) == -1)
    {
		printf("222\n");
        res_Write = mkfifo(FIFO_NAME_WRITE, 0766);
        if(res_Write != 0)
        {
			printf("333\n");
            fprintf(stderr, "Could not create fifo %s\n", FIFO_NAME_WRITE);
            exit(EXIT_FAILURE);
        }
    }
	printf("444\n");
    pipe_fd_Write = open(FIFO_NAME_WRITE, O_WRONLY);
	printf("555\n");
    if(pipe_fd_Write == -1) exit(EXIT_FAILURE);
    printf("Process %d opening FIFO O_WRONLY\n", getpid());
    printf("the file's descriptor is %d \n", pipe_fd_Write);
}

void FpgaCPU::getWrite(uint64_t input)
{
    //printf("please input message:\n");
    //scanf("%s",bufferWrite);

    sprintf(bufferWrite,"%lu",input);
    pipe_fd_Write = open(FIFO_NAME_WRITE, O_WRONLY);
    res_Write = write(pipe_fd_Write, bufferWrite, sizeof(bufferWrite));
    close(pipe_fd_Write);
    if(res_Write == -1)
    {
        fprintf(stderr, "Write error on pipe\n");
        exit(EXIT_FAILURE);
    }
}


void FpgaCPU::createRead()
{
    bytes_read = 0;
    memset(bufferRead, '\0', sizeof(bufferRead));
    printf("Process %d opening FIFO O_RDONLY", getpid());
    pipe_fd_Read = open(FIFO_NAME_READ, O_RDONLY);
    printf("the files descriptor is %d \n", pipe_fd_Read);
    if(pipe_fd_Read == -1) exit(EXIT_FAILURE);
}

void FpgaCPU::getRead(uint64_t* output)
{
    pipe_fd_Read = open(FIFO_NAME_READ, O_RDONLY);
    bytes_read = read(pipe_fd_Read, bufferRead, sizeof(bufferRead));
    while (!bytes_read)
        bytes_read = read(pipe_fd_Read, bufferRead, sizeof(bufferRead));
    close(pipe_fd_Read);
    sscanf(bufferRead,"%lu",output);
}




void FpgaCPU::createShare()
{
	running = 1;
	shared = NULL;
    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);
    if(shmid == -1)
    {
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }
    shm = shmat(shmid, (void*)0, 0);
    if(shm == (void*)-1)
    {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
    printf("Memory attached at %llX\n", (unsigned long long)shm);
}

void FpgaCPU::deleteShare()
{
    if(shmdt(shm) == -1)
    {
        fprintf(stderr, "shmdt failed\n");
        exit(EXIT_FAILURE);
    }
}

//----------------------------------------------------------------------------------------
//The above part is for the communication between two processes


void
FpgaCPU::init()
{
    BaseSimpleCPU::init();
	if (controlPort.isConnected())
		controlPort.sendRangeChange();
	else
		fatal("FPGA controlPort is unconnected!\n");
}

void
FpgaCPU::FpgaCPUPort::TickEvent::schedule(PacketPtr _pkt, Tick t)
{
   // cout << "FpgaCPU::FpgaCPUPort::TickEvent::schedule(PacketPtr _pkt, Tick t)"  << endl;
    pkt = _pkt;
    cpu->schedule(this, t);
}


//make sure that the fetch action will be executed before any other event
//by setting the priority of fetchEvent higher than other default event (eventq.hh)
FpgaCPU::FpgaCPU(FpgaCPUParams *p)
    : BaseSimpleCPU(p), latency(5000),num_output_fpga(p->num_output_fpga), num_input_fpga(p->num_input_fpga), ControlAddr(p->fpga_bus_addr), fetchTranslation(this), icachePort(this),
      dcachePort(this), controlPort(this,p), ifetch_pkt(NULL), dcache_pkt(NULL),
      previousCycle(0),fetchEvent(this,false,-51), releaseEvent(this), dequeueEvent(this),baseaddress_control_fpga(p->baseaddress_control_fpga),size_control_fpga(p->size_control_fpga)
	  
{
    _status = Idle;
	OccupyFPGA = 0;
	curThread = 0;
}



FpgaCPU::~FpgaCPU()
{
}

DrainState
FpgaCPU::drain()
{
    if (switchedOut())
        return DrainState::Drained;

    if (_status == Idle ||
        (_status == BaseSimpleCPU::Running && isDrained())) {
        DPRINTF(Drain, "No need to drain.\n");
        activeThreads.clear();
        return DrainState::Drained;
    } else {
        DPRINTF(Drain, "Requesting drain.\n");

        // The fetch event can become descheduled if a drain didn't
        // succeed on the first attempt. We need to reschedule it if
        // the CPU is waiting for a microcode routine to complete.
        if (_status == BaseSimpleCPU::Running && !fetchEvent.scheduled())
            schedule(fetchEvent, clockEdge());

        return DrainState::Draining;
    }
}

void
FpgaCPU::drainResume()
{
    assert(!fetchEvent.scheduled());
    if (switchedOut())
        return;

    DPRINTF(SimpleCPU, "Resume\n");
    verifyMemoryMode();

    assert(!threadContexts.empty());

    _status = BaseSimpleCPU::Idle;

    for (ThreadID tid = 0; tid < numThreads; tid++) {
        if (threadInfo[tid]->thread->status() == ThreadContext::Active) {
            threadInfo[tid]->notIdleFraction = 1;

            activeThreads.push_back(tid);

            _status = BaseSimpleCPU::Running;

            // Fetch if any threads active
            if (!fetchEvent.scheduled()) {
                schedule(fetchEvent, nextCycle());
            }
        } else {
            threadInfo[tid]->notIdleFraction = 0;
        }
    }

    system->totalNumInsts = 0;
}

bool
FpgaCPU::tryCompleteDrain()
{
    if (drainState() != DrainState::Draining)
        return false;

    DPRINTF(Drain, "tryCompleteDrain.\n");
    if (!isDrained())
        return false;

    DPRINTF(Drain, "CPU done draining, processing drain event\n");
    signalDrainDone();

    return true;
}

void
FpgaCPU::switchOut()
{
    SimpleExecContext& t_info = *threadInfo[curThread];
    M5_VAR_USED SimpleThread* thread = t_info.thread;

    BaseSimpleCPU::switchOut();

    assert(!fetchEvent.scheduled());
    assert(_status == BaseSimpleCPU::Running || _status == Idle);
    assert(!t_info.stayAtPC);
    assert(thread->microPC() == 0);

    updateCycleCounts();
}


void
FpgaCPU::takeOverFrom(BaseCPU *oldCPU)
{
    BaseSimpleCPU::takeOverFrom(oldCPU);

    previousCycle = curCycle();
}

void
FpgaCPU::verifyMemoryMode() const
{
    if (!system->isTimingMode()) {
        fatal("The timing CPU requires the memory system to be in "
              "'timing' mode.\n");
    }
}

#define FILEPATH_MAX (80)

void
FpgaCPU::activateContext(ThreadID thread_num)
{
	cout << "FpgaCPU::activateContext" << curCycle() << endl;
//    DPRINTF(SimpleCPU, "ActivateContext %d\n", thread_num);

//    assert(thread_num < numThreads);
//
  //  threadInfo[thread_num]->notIdleFraction = 1;
    if (_status == BaseSimpleCPU::Idle)
        _status = BaseSimpleCPU::Running;

	RunState = 0;
    ReadReady = 0;
    WriteReady = 0;
    edge_RENA = 0;
    edge_WENA = 0;
    ReadEnable = 0;
    WriteEnable = 0;
	Terminate = 0;

    memset(inputArray,0,sizeof(inputArray));
    memset(outputArray,0,sizeof(outputArray));
    inputArray[bit_Run] = 1;
   // char buf[80];
  //  printf("current working directory: %s\n", getcwd(buf,sizeof(buf)));

//	system("pwd");
	createShare();
	shared = (struct shared_use_st*)shm;
	shared->text[num_input_fpga+num_output_fpga] = 0;
    shared->written = 0;
   // for (int i=0;i<num_input_fpga+num_output_fpga;i++)
      //  shared->text[i]=0;
//	printf("activate context\n");
    pid_t fpid;
    fpid = fork();
    if (fpid == 0)
    {
		//printf("child process\n");
        int rc=execl("./FpgaModule","FpgaModule",(char*)0);
		if (rc == -1)
			fatal("fpga process can not work");
     //   while (1);
    }
//	printf("parent process\n\n");
	
    schedule(fetchEvent, clockEdge(Cycles(0)));
   /* if (std::find(activeThreads.begin(), activeThreads.end(), thread_num)
         == activeThreads.end()) {
        activeThreads.push_back(thread_num);
    }*/

  //  BaseCPU::activateContext(thread_num);
}


void
FpgaCPU::suspendContext(ThreadID thread_num)
{
//cout << "suspendContext" << curCycle() << endl;
    DPRINTF(SimpleCPU, "SuspendContext %d\n", thread_num);

    assert(thread_num < numThreads);
    activeThreads.remove(thread_num);

    if (_status == Idle)
        return;

    assert(_status == BaseSimpleCPU::Running);

    threadInfo[thread_num]->notIdleFraction = 0;

    if (activeThreads.empty()) {
        _status = Idle;

        if (fetchEvent.scheduled()) {
            deschedule(fetchEvent);
        }
    }

    BaseCPU::suspendContext(thread_num);
}

bool
FpgaCPU::handleReadPacket(PacketPtr pkt)
{

//cout << "handleReadPacket" << curCycle() << endl;
   // RequestPtr req = pkt->req;

    // We're about the issues a locked load, so tell the monitor
    // to start caring about this address
   /* if (pkt->isRead() && pkt->req->isLLSC()) {
        TheISA::handleLockedRead(thread, pkt->req);
    }
    if (req->isMmappedIpr()) {
        Cycles delay = TheISA::handleIprRead(thread->getTC(), pkt);
        new IprEvent(pkt, this, clockEdge(delay));
        _status = DcacheWaitResponse;
        dcache_pkt = NULL;
    } else */
//	printf("virtual address -- > %lu\n",pkt->req->getVaddr());
//	printf("physical address -- > %lu\n",pkt->req->getPaddr());
    if (!dcachePort.sendTimingReq(pkt)) {
        _status = DcacheRetry;
        dcache_pkt = pkt;
    } else {
        _status = DcacheWaitResponse;
        // memory system takes ownership of packet
        dcache_pkt = NULL;
    }
    return dcache_pkt == NULL;
}

void
FpgaCPU::sendData(RequestPtr req, uint8_t *data, uint64_t *res,
                          bool read)
{
//cout << "sendData" << curCycle() << endl;
  //  SimpleExecContext &t_info = *threadInfo[curThread];
  //  SimpleThread* thread = t_info.thread;
    PacketPtr pkt = buildPacket(req, read);
    pkt->dataDynamic<uint8_t>(data);
    if (req->getFlags().isSet(Request::NO_ACCESS)) {
        assert(!dcache_pkt);
        pkt->makeResponse();
        completeDataAccess(pkt);
    } else if (read) {
        handleReadPacket(pkt);
    } else {
        bool do_access = true;  // flag to suppress cache access
/*
        if (req->isLLSC()) {
            do_access = TheISA::handleLockedWrite(thread, req, dcachePort.cacheBlockMask);
        } else if (req->isCondSwap()) {
            assert(res);
            req->setExtraData(*res);
        }*/

        if (do_access) {
            dcache_pkt = pkt;
            handleWritePacket();
	//		threadSnoop(pkt, curThread);
        } else {
            _status = DcacheWaitResponse;
            completeDataAccess(pkt);
        }
    }
}

void
FpgaCPU::sendSplitData(RequestPtr req1, RequestPtr req2,
                               RequestPtr req, uint8_t *data, bool read)
{
    PacketPtr pkt1, pkt2;
    buildSplitPacket(pkt1, pkt2, req1, req2, req, data, read);
    if (req->getFlags().isSet(Request::NO_ACCESS)) {
        assert(!dcache_pkt);
        pkt1->makeResponse();
        completeDataAccess(pkt1);
    } else if (read) {
        SplitFragmentSenderState * send_state =
            dynamic_cast<SplitFragmentSenderState *>(pkt1->senderState);
        if (handleReadPacket(pkt1)) {
            send_state->clearFromParent();
            send_state = dynamic_cast<SplitFragmentSenderState *>(
                    pkt2->senderState);
            if (handleReadPacket(pkt2)) {
                send_state->clearFromParent();
            }
        }
    } else {
        dcache_pkt = pkt1;
        SplitFragmentSenderState * send_state =
            dynamic_cast<SplitFragmentSenderState *>(pkt1->senderState);
        if (handleWritePacket()) {
            send_state->clearFromParent();
            dcache_pkt = pkt2;
            send_state = dynamic_cast<SplitFragmentSenderState *>(
                    pkt2->senderState);
            if (handleWritePacket()) {
                send_state->clearFromParent();
            }
        }
    }
}

void
FpgaCPU::translationFault(const Fault &fault)
{
    // fault may be NoFault in cases where a fault is suppressed,
    // for instance prefetches.
    updateCycleCounts();

    if (traceData) {
        // Since there was a fault, we shouldn't trace this instruction.
        delete traceData;
        traceData = NULL;
    }

    //postExecute();

    advanceInst(fault);
}

PacketPtr
FpgaCPU::buildPacket(RequestPtr req, bool read)
{
//cout << "buildPacket" << curCycle() << endl;

    return read ? Packet::createRead(req) : Packet::createWrite(req);
}

void
FpgaCPU::buildSplitPacket(PacketPtr &pkt1, PacketPtr &pkt2,
        RequestPtr req1, RequestPtr req2, RequestPtr req,
        uint8_t *data, bool read)
{
    pkt1 = pkt2 = NULL;

    assert(!req1->isMmappedIpr() && !req2->isMmappedIpr());

    if (req->getFlags().isSet(Request::NO_ACCESS)) {
        pkt1 = buildPacket(req, read);
        return;
    }

    pkt1 = buildPacket(req1, read);
    pkt2 = buildPacket(req2, read);

    PacketPtr pkt = new Packet(req, pkt1->cmd.responseCommand());

    pkt->dataDynamic<uint8_t>(data);
    pkt1->dataStatic<uint8_t>(data);
    pkt2->dataStatic<uint8_t>(data + req1->getSize());

    SplitMainSenderState * main_send_state = new SplitMainSenderState;
    pkt->senderState = main_send_state;
    main_send_state->fragments[0] = pkt1;
    main_send_state->fragments[1] = pkt2;
    main_send_state->outstanding = 2;
    pkt1->senderState = new SplitFragmentSenderState(pkt, 0);
    pkt2->senderState = new SplitFragmentSenderState(pkt, 1);
}

Fault
FpgaCPU::readMem(Addr addr, uint8_t *data,
                         unsigned size, Request::Flags flags)
{
    panic("readMem() is for atomic accesses, and should "
          "never be called on TimingSimpleCPU.\n");
}

Fault
FpgaCPU::initiateMemRead(Addr addr, unsigned size,
                          Request::Flags flags)
{
//cout << "readMem" << curCycle() << endl;
    Fault fault;
    const int asid = 0;
    ThreadID tid = CurrentThreadID;
    ThreadContext* CurrentTC = system->getThreadContext(tid);
    const Addr pc = 0;
    unsigned block_size = cacheLineSize();
    BaseTLB::Mode mode = BaseTLB::Read;
    if (traceData)
        traceData->setMem(addr, size, flags);

    RequestPtr req  = new Request(asid, addr, size,
                                  flags, dataMasterId(), pc, tid);

    req->taskId(taskId());

    Addr split_addr = roundDown(addr + size - 1, block_size);
    assert(split_addr <= addr || split_addr - addr < block_size);

    _status = DTBWaitResponse;
    if (split_addr > addr) {
        RequestPtr req1, req2;
        assert(!req->isLLSC() && !req->isSwap());
        req->splitOnVaddr(split_addr, req1, req2);

        WholeTranslationState *state =
            new WholeTranslationState(req, req1, req2, new uint8_t[size],
                                      NULL, mode);
        DataTranslation<FpgaCPU *> *trans1 =
            new DataTranslation<FpgaCPU *>(this, state, 0);
        DataTranslation<FpgaCPU *> *trans2 =
            new DataTranslation<FpgaCPU *>(this, state, 1);

        CurrentTC->getDTBPtr()->translateTiming(req1, CurrentTC, trans1, mode);
        CurrentTC->getDTBPtr()->translateTiming(req2, CurrentTC, trans2, mode);
    } else {
        WholeTranslationState *state =
            new WholeTranslationState(req, new uint8_t[size], NULL, mode);
        DataTranslation<FpgaCPU *> *translation
            = new DataTranslation<FpgaCPU *>(this, state);
        CurrentTC->getDTBPtr()->translateTiming(req, CurrentTC, translation, mode);
    }


    return NoFault;
}

bool
FpgaCPU::handleWritePacket()
{
//cout << "handleWritePacket" << curCycle() << endl;
   // RequestPtr req = dcache_pkt->req;
    /*
    if (req->isMmappedIpr()) {
        Cycles delay = TheISA::handleIprWrite(thread->getTC(), dcache_pkt);
        new IprEvent(dcache_pkt, this, clockEdge(delay));
        _status = DcacheWaitResponse;
        dcache_pkt = NULL;
    } else */
	//printf("virtual address -- > %lu\n",dcache_pkt->req->getVaddr());
	//printf("physical address -- > %lu\n",dcache_pkt->req->getPaddr());
    if (!dcachePort.sendTimingReq(dcache_pkt)) {
        _status = DcacheRetry;
    } else {
        _status = DcacheWaitResponse;
        // memory system takes ownership of packet
        dcache_pkt = NULL;
    }
    return dcache_pkt == NULL;
}

static inline uint64_t
getMem(PacketPtr pkt, unsigned dataSize, Trace::InstRecord *traceData)
{
    uint64_t mem;
    switch (dataSize)
    {
        case 1:
            mem = pkt->get<uint8_t>(); break;
        case 2:
            mem = pkt->get<uint16_t>(); break;
        case 4:
            mem = pkt->get<uint32_t>();break;
        case 8:
            mem = pkt->get<uint64_t>();break;
        default:
            fatal("Unhandled size in getMem.\n");
    }
    if (traceData)
        traceData->setData(mem);
    return mem;
}

Fault
FpgaCPU::writeMem(uint8_t *data, unsigned size, Addr addr, Request::Flags flags, uint64_t *res)
{
//cout << "writeMem" << curCycle() << endl;
  //  printf("w1");
    uint8_t *newData = new uint8_t[size];
    const int asid = 0;
    ThreadID tid = CurrentThreadID;
	ThreadContext* CurrentTC = system->getThreadContext(tid);
    const Addr pc = 0;
    unsigned block_size = cacheLineSize();
    BaseTLB::Mode mode = BaseTLB::Write;

    //printf("w2");
    if (data == NULL) {
        assert(flags & Request::CACHE_BLOCK_ZERO);
        // This must be a cache block cleaning request
        memset(newData, 0, size);
    } else {
        memcpy(newData, data, size);
    }

   // printf("w3");
    if (traceData)
        traceData->setMem(addr, size, flags);

    RequestPtr req = new Request(asid, addr, size,
                                 flags, dataMasterId(), pc, tid);
   // printf("inst_req1: %d\n",req->isInstFetch());
 //   printf("w4");
    req->taskId(taskId());

 //   printf("inst_req2: %d\n",req->isInstFetch());
  //  printf("w4");
    Addr split_addr = roundDown(addr + size - 1, block_size);
    assert(split_addr <= addr || split_addr - addr < block_size);

   // printf("inst_req3: %d\n",req->isInstFetch());
  //  printf("w4");
  //  printf("w5");
    _status = DTBWaitResponse;
    if (split_addr > addr) {
        RequestPtr req1, req2;
        assert(!req->isLLSC() && !req->isSwap());
        req->splitOnVaddr(split_addr, req1, req2);

        WholeTranslationState *state =
            new WholeTranslationState(req, req1, req2, newData, res, mode);
        DataTranslation<FpgaCPU *> *trans1 =
            new DataTranslation<FpgaCPU *>(this, state, 0);
        DataTranslation<FpgaCPU *> *trans2 =
            new DataTranslation<FpgaCPU *>(this, state, 1);

        CurrentTC->getDTBPtr()->translateTiming(req1, CurrentTC, trans1, mode);
        CurrentTC->getDTBPtr()->translateTiming(req2, CurrentTC, trans2, mode);
    } else {
   // printf("w6");
        WholeTranslationState *state =
            new WholeTranslationState(req, newData, res, mode);
        DataTranslation<FpgaCPU *> *translation =
            new DataTranslation<FpgaCPU *>(this, state);
   // printf("w7");
   // printf("inst_req4: %d\n",req->isInstFetch());
  //  printf("w4");
        CurrentTC->getDTBPtr()->translateTiming(req, CurrentTC, translation, mode);
    }
    // Translation faults will be returned via finishTranslation()
    return NoFault;
}

void
FpgaCPU::threadSnoop(PacketPtr pkt, ThreadID sender)
{
    for (ThreadID tid = 0; tid < numThreads; tid++) {
        if (tid != sender) {
            if (getCpuAddrMonitor(tid)->doMonitor(pkt)) {
                wakeup(tid);
            }
            TheISA::handleLockedSnoop(threadInfo[tid]->thread, pkt,
                    dcachePort.cacheBlockMask);
        }
    }
}

void
FpgaCPU::finishTranslation(WholeTranslationState *state)
{
//cout << "finishTranslation" << curCycle() << endl;
    _status = BaseSimpleCPU::Running;

    if (state->getFault() != NoFault) {
        if (state->isPrefetch()) {
            state->setNoFault();
        }
     //   printf("virt addr -- %lu\n",state->mainReq->getVaddr());
     //   printf("phys addr -- %lu\n",state->mainReq->getPaddr());
        delete [] state->data;
        state->deleteReqs();
        translationFault(state->getFault());
    } else {
        if (!state->isSplit) {
            sendData(state->mainReq, state->data, state->res,
                     state->mode == BaseTLB::Read);
        } else {
            sendSplitData(state->sreqLow, state->sreqHigh, state->mainReq,
                          state->data, state->mode == BaseTLB::Read);
        }
    }

    delete state;
}




void
FpgaCPU::fetch()  //FPGACPU-special==========================actually FPGA has no procedure of fetching but it can as a procedure of communicating with another process of verilator
{
	//cout << "fetch" << curCycle() << endl;
    DPRINTF(SimpleCPU, "Fetch\n");

	if (Terminate == 1)
		{
            shared->text[num_input_fpga+num_output_fpga] = 10101;
			shared->written = 1;
			exitSimLoop("as the end of simulation, FPGA is terminated. exit()\n");
			return;
        }
	else shared->text[num_input_fpga+num_output_fpga] = 0;

    schedule(fetchEvent, clockEdge(Cycles(1)));// insert another procedure of fetch at next cycle.
    if (_status == Idle)
        return;
	if (!OccupyFPGA) {return;}

    InputChanged = 0;
    OutputChanged = 0;
    while(shared->written == 1) /*printf("waiting\n")*/{InputChanged = 0;};
   /* 
	printf("cpu---");
    for (int i=0;i<num_input_fpga+num_output_fpga;i++)
        printf("%d:%llu ",i,shared->text[i]);printf("\n");*/
//	printf("FPGA output:\n");
    for (cnt=num_input_fpga;cnt<num_input_fpga+num_output_fpga;cnt++)
    {
        outputArray[cnt-num_input_fpga]=shared->text[cnt];
   //     printf("output [%d]: %lu\n",cnt,outputArray[cnt-num_input_fpga]);
        if (outputArray[cnt-num_input_fpga] != outputArray_last[cnt-num_input_fpga])
        {
            OutputChanged = 1;
        }
    }
   // printf("FPGA input: %d\n",num_input_fpga);
    for (cnt=0;cnt<num_input_fpga;cnt++)
    {
        shared->text[cnt]=inputArray[cnt];
     //   printf("intput [%d]: %lu\n",cnt,inputArray[cnt]);
        if (inputArray[cnt] != inputArray_last[cnt])
        {
            InputChanged = 1;
        }
    }


	shared->written = 1;
	////////////////////////////////////////////////////////////////////////
////////for    test////////////////////////////////////////////////////
 //  printf("WriteReady : %lu\n",inputArray[bit_WriteReady]);
 //   printf("ReadReady : %lu\n",inputArray[bit_ReadReady]);
   // printf("CPU-RESET -- %lu\n",inputArray[bit_Run]);
   // if (RunState)  //printf("ReadData : %lu  CurrentThreadID -- %lu  MemoryRange -- %lu  MemorySize -- %lu  RunState -- %lu ReadBase -- %lu WriteBase -- %lu  WriteData  -- %lu\n",inputArray[bit_ReadData],CurrentThreadID,MemoryRange,MemorySize,RunState,ReadBase,WriteBase,outputArray[bit_WriteData]);
     //   printf("ReadAddr--%lu ReadEnable--%lu ReadSize--%lu ReadData--%lu\n",outputArray[bit_ReadAddr],outputArray[bit_ReadEnable],outputArray[bit_Size_ReadData_Output],inputArray[bit_ReadData]);
  //   Process *p = system->getThreadContext(CurrentThreadID)->getProcessPtr();
   // printf("t6");
  //  if (p->pTable->isUnmapped(outputArray[bit_WriteAddr], outputArray[bit_Size_WriteData])&&outputArray[bit_WriteAddr] == 0xfffff000)
	//	p->pTable->map(outputArray[bit_WriteAddr], 1<<28, outputArray[bit_Size_WriteData],0);   
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

	if (outputArray[bit_Done]) {RunState = 0;}
    if (OutputChanged)
    {
        //ReadEnable
        if (outputArray_last[bit_ReadEnable] != outputArray[bit_ReadEnable])
        {
            ReadEnable = outputArray[bit_ReadEnable];
            if (outputArray_last[bit_ReadEnable] < outputArray[bit_ReadEnable]) edge_RENA = 1;
            else edge_RENA = 0;
        }
        else edge_RENA = 0;
        //WriteEnabel
        if (outputArray_last[bit_WriteEnable] != outputArray[bit_WriteEnable])
        {
            WriteEnable = outputArray[bit_WriteEnable];
            if (outputArray_last[bit_WriteEnable] < outputArray[bit_WriteEnable]) edge_WENA = 1;
            else edge_WENA = 0;
        }
        else edge_WENA = 0;
    }
	else {edge_RENA = 0;edge_WENA = 0;}

    for (cnt = 0; cnt < 16; cnt++)
        outputArray_last[cnt] = outputArray[cnt];
    for (cnt = 0; cnt < 16; cnt++)
        inputArray_last[cnt] = inputArray[cnt];

	inputArray[bit_ReadReady] = 0;
	inputArray[bit_WriteReady] = 0;
  //  printf("RNA %d OABFR %lu  EDRNA %d\n",ReadEnable,outputArray[bit_FinishRead],edge_RENA);
    if (ReadEnable && (outputArray[bit_FinishRead] || edge_RENA))
    {
       // printf("read enable\n");
      //  sleep(1);
        ReadReady = 0;
        inputArray[bit_ReadReady] = 0;
        initiateMemRead(outputArray[bit_ReadAddr], outputArray[bit_Size_ReadData_Output],0);
        //FpgaCPU::readMem(Addr addr, uint8_t *data, unsigned size, unsigned flags)
    }
    else if (outputArray[bit_FinishRead]||!ReadEnable)
    {
        inputArray[bit_ReadReady] = 0;
        ReadReady = 0;
    }

   // printf("WNA %d OABFW %lu  EDWNA %d\n",WriteEnable,outputArray[bit_FinishWrite],edge_WENA);
    if (WriteEnable && (outputArray[bit_FinishWrite] || edge_WENA))
    {
       // printf("write enable\n");
      //  sleep(10);
        WriteReady = 0;
        inputArray[bit_WriteReady] = 0;

        writeMem((uint8_t*)&outputArray[bit_WriteData], outputArray[bit_Size_WriteData],
                 outputArray[bit_WriteAddr], 0, NULL);
    }
    else if (outputArray[bit_FinishWrite]||!WriteEnable)
    {
        inputArray[bit_WriteReady] = 0;
        WriteReady = 0;
    }


}


void
FpgaCPU::sendFetch(const Fault &fault, RequestPtr req,
                           ThreadContext *tc)
{
//cout << "sendFetch" << curCycle() << endl;
    if (fault == NoFault) {
        DPRINTF(SimpleCPU, "Sending fetch for addr %#x(pa: %#x)\n",
                req->getVaddr(), req->getPaddr());
        ifetch_pkt = new Packet(req, MemCmd::ReadReq);
        ifetch_pkt->dataStatic(&inst);
        DPRINTF(SimpleCPU, " -- pkt addr: %#x\n", ifetch_pkt->getAddr());

        if (!icachePort.sendTimingReq(ifetch_pkt)) {
            // Need to wait for retry
            _status = IcacheRetry;
        } else {
            // Need to wait for cache to respond
            _status = IcacheWaitResponse;
            // ownership of packet transferred to memory system
            ifetch_pkt = NULL;
        }
    } else {
        DPRINTF(SimpleCPU, "Translation of addr %#x faulted\n", req->getVaddr());
        delete req;
        // fetch fault: advance directly to next instruction (fault handler)
        _status = BaseSimpleCPU::Running;
        advanceInst(fault);
    }

    updateCycleCounts();
}


void
FpgaCPU::advanceInst(const Fault &fault)
{
//cout << "advanceInst" << curCycle() << endl;
    SimpleExecContext &t_info = *threadInfo[curThread];

    if (_status == Faulting)
        return;

    if (fault != NoFault) {
        advancePC(fault);
        DPRINTF(SimpleCPU, "Fault occured, scheduling fetch event\n");
        reschedule(fetchEvent, clockEdge(), true);
        _status = Faulting;
        return;
    }


    if (!t_info.stayAtPC)
        advancePC(fault);

    if (tryCompleteDrain())
            return;

    if (_status == BaseSimpleCPU::Running) {
        // kick off fetch of next instruction... callback from icache
        // response will cause that instruction to be executed,
        // keeping the CPU running.
        fetch();
    }
}


void
FpgaCPU::completeIfetch(PacketPtr pkt)
{
//cout << "completeIfetch" << curCycle() << endl;
    SimpleExecContext& t_info = *threadInfo[curThread];

    DPRINTF(SimpleCPU, "Complete ICache Fetch for addr %#x\n", pkt ?
            pkt->getAddr() : 0);

    // received a response from the icache: execute the received
    // instruction
    assert(!pkt || !pkt->isError());
    assert(_status == IcacheWaitResponse);

    _status = BaseSimpleCPU::Running;

    updateCycleCounts();

    if (pkt)
        pkt->req->setAccessLatency();


    preExecute();
    if (curStaticInst && curStaticInst->isMemRef()) {
        // load or store: just send to dcache
        Fault fault = curStaticInst->initiateAcc(&t_info, traceData);

        // If we're not running now the instruction will complete in a dcache
        // response callback or the instruction faulted and has started an
        // ifetch
        if (_status == BaseSimpleCPU::Running) {
            if (fault != NoFault && traceData) {
                // If there was a fault, we shouldn't trace this instruction.
                delete traceData;
                traceData = NULL;
            }

            postExecute();
            // @todo remove me after debugging with legion done
            if (curStaticInst && (!curStaticInst->isMicroop() ||
                        curStaticInst->isFirstMicroop()))
                instCnt++;
            advanceInst(fault);
        }
    } else if (curStaticInst) {
        // non-memory instruction: execute completely now
        Fault fault = curStaticInst->execute(&t_info, traceData);

        // keep an instruction count
        if (fault == NoFault)
            countInst();
        else if (traceData && !DTRACE(ExecFaulting)) {
            delete traceData;
            traceData = NULL;
        }

        postExecute();
        // @todo remove me after debugging with legion done
        if (curStaticInst && (!curStaticInst->isMicroop() ||
                curStaticInst->isFirstMicroop()))
            instCnt++;
        advanceInst(fault);
    } else {
        advanceInst(NoFault);
    }

    if (pkt) {
        delete pkt->req;
        delete pkt;
    }
}

void
FpgaCPU::IcachePort::ITickEvent::process()
{
//cout << "FpgaCPU::IcachePort::ITickEvent::process()"  << endl;
    cpu->completeIfetch(pkt);
}

bool
FpgaCPU::IcachePort::recvTimingResp(PacketPtr pkt)
{
//cout << "FpgaCPU::IcachePort::recvTimingResp(PacketPtr pkt)"  << endl;
    DPRINTF(SimpleCPU, "Received fetch response %#x\n", pkt->getAddr());
    // we should only ever see one response per cycle since we only
    // issue a new request once this response is sunk
    assert(!tickEvent.scheduled());
    // delay processing of returned data until next CPU clock edge
    tickEvent.schedule(pkt, cpu->clockEdge());

    return true;
}

void
FpgaCPU::IcachePort::recvReqRetry()
{
//cout << "FpgaCPU::IcachePort::recvReqRetry()"  << endl;
    // we shouldn't get a retry unless we have a packet that we're
    // waiting to transmit
    assert(cpu->ifetch_pkt != NULL);
    assert(cpu->_status == IcacheRetry);
    PacketPtr tmp = cpu->ifetch_pkt;
    if (sendTimingReq(tmp)) {
        cpu->_status = IcacheWaitResponse;
        cpu->ifetch_pkt = NULL;
    }
}

void
FpgaCPU::completeDataAccess(PacketPtr pkt)
{
//cout << "completeDataAccess" << curCycle() << endl;
    // received a response from the dcache: complete the load or store
    // instruction
    assert(!pkt->isError());
    assert(_status == DcacheWaitResponse || _status == DTBWaitResponse ||
           pkt->req->getFlags().isSet(Request::NO_ACCESS));

    pkt->req->setAccessLatency();

    updateCycleCounts();
/*
    if (pkt->senderState) {
        SplitFragmentSenderState * send_state =
            dynamic_cast<SplitFragmentSenderState *>(pkt->senderState);
        assert(send_state);
        delete pkt->req;
        delete pkt;
        PacketPtr big_pkt = send_state->bigPkt;
        delete send_state;

        SplitMainSenderState * main_send_state =
            dynamic_cast<SplitMainSenderState *>(big_pkt->senderState);
        assert(main_send_state);
        // Record the fact that this packet is no longer outstanding.
        assert(main_send_state->outstanding != 0);
        main_send_state->outstanding--;

        if (main_send_state->outstanding) {
            return;
        } else {
            delete main_send_state;
            big_pkt->senderState = NULL;
            pkt = big_pkt;
        }
    }
*/
    _status = BaseSimpleCPU::Running;

    //Fault fault = curStaticInst->completeAcc(pkt, this, traceData);
    Fault fault = NoFault;
  //  int yyyy;
    if (pkt->cmd == MemCmd::ReadResp)
    {
    //    printf("done Read\n");
	//	sleep(10);
  //      if (scanf("%d",&yyyy)==-1111) return ;
        ReadReady = 1;
        inputArray[bit_ReadReady] = 1;
	//	printf("pkt size -- %d\n",pkt->getSize());
        inputArray[bit_ReadData] = getMem(pkt, outputArray[bit_Size_ReadData_Output], traceData);
    }

    if (pkt->cmd == MemCmd::WriteResp)
    {
   //     printf("done write\n");
       // if (scanf("%d",&yyyy)==-111) return ;
        WriteReady = 1;
        inputArray[bit_WriteReady] = 1;
    }

    // keep an instruction count
/*  if (fault == NoFault)
        countInst();
    else if (traceData) {
        // If there was a fault, we shouldn't trace this instruction.
        delete traceData;
        traceData = NULL;
    }
*/
    delete pkt->req;
    delete pkt;
  //  if (yyyy == 111111111) return;
 //   postExecute();

    //advanceInst(fault);
}

void
FpgaCPU::updateCycleCounts()
{
//cout << "updateCycleCounts" << curCycle() << endl;
    const Cycles delta(curCycle() - previousCycle);

    numCycles += delta;
    ppCycles->notify(delta);

    previousCycle = curCycle();
}

void
FpgaCPU::DcachePort::recvTimingSnoopReq(PacketPtr pkt)
{
//cout << "FpgaCPU::DcachePort::recvTimingSnoopReq(PacketPtr pkt)"  << endl;
    // X86 ISA: Snooping an invalidation for monitor/mwait
    for (ThreadID tid = 0; tid < cpu->numThreads; tid++) {
        if (cpu->getCpuAddrMonitor(tid)->doMonitor(pkt)) {
            cpu->wakeup(tid);
        }
    }

    // Making it uniform across all CPUs:
    // The CPUs need to be woken up only on an invalidation packet (when using caches)
    // or on an incoming write packet (when not using caches)
    // It is not necessary to wake up the processor on all incoming packets
    if (pkt->isInvalidate() || pkt->isWrite()) {
        for (auto &t_info : cpu->threadInfo) {
            TheISA::handleLockedSnoop(t_info->thread, pkt, cacheBlockMask);
        }
    }
}

void
FpgaCPU::DcachePort::recvFunctionalSnoop(PacketPtr pkt)
{
//cout << "FpgaCPU::DcachePort::recvFunctionalSnoop(PacketPtr pkt)"  << endl;
    // X86 ISA: Snooping an invalidation for monitor/mwait
    for (ThreadID tid = 0; tid < cpu->numThreads; tid++) {
        if (cpu->getCpuAddrMonitor(tid)->doMonitor(pkt)) {
            cpu->wakeup(tid);
        }
    }
}

bool
FpgaCPU::DcachePort::recvTimingResp(PacketPtr pkt)
{
//cout << "FpgaCPU::DcachePort::recvTimingResp(PacketPtr pkt)"  << endl;
    DPRINTF(SimpleCPU, "Received load/store response %#x\n", pkt->getAddr());

    // The timing CPU is not really ticked, instead it relies on the
    // memory system (fetch and load/store) to set the pace.
    if (!tickEvent.scheduled()) {
        // Delay processing of returned data until next CPU clock edge
        tickEvent.schedule(pkt, cpu->clockEdge());
        return true;
    } else {
        // In the case of a split transaction and a cache that is
        // faster than a CPU we could get two responses in the
        // same tick, delay the second one
        if (!retryRespEvent.scheduled())
            cpu->schedule(retryRespEvent, cpu->clockEdge(Cycles(1)));
        return false;
    }
}

void
FpgaCPU::DcachePort::DTickEvent::process()
{
//cout << "FpgaCPU::DcachePort::DTickEvent::process()"  << endl;
    cpu->completeDataAccess(pkt);
}

void
FpgaCPU::DcachePort::recvReqRetry()
{
//cout << "FpgaCPU::DcachePort::recvReqRetry()"  << endl;
    // we shouldn't get a retry unless we have a packet that we're
    // waiting to transmit
    assert(cpu->dcache_pkt != NULL);
    assert(cpu->_status == DcacheRetry);
    PacketPtr tmp = cpu->dcache_pkt;
    if (tmp->senderState) {
        // This is a packet from a split access.
        SplitFragmentSenderState * send_state =
            dynamic_cast<SplitFragmentSenderState *>(tmp->senderState);
        assert(send_state);
        PacketPtr big_pkt = send_state->bigPkt;

        SplitMainSenderState * main_send_state =
            dynamic_cast<SplitMainSenderState *>(big_pkt->senderState);
        assert(main_send_state);

        if (sendTimingReq(tmp)) {
            // If we were able to send without retrying, record that fact
            // and try sending the other fragment.
            send_state->clearFromParent();
            int other_index = main_send_state->getPendingFragment();
            if (other_index > 0) {
                tmp = main_send_state->fragments[other_index];
                cpu->dcache_pkt = tmp;
                if ((big_pkt->isRead() && cpu->handleReadPacket(tmp)) ||
                        (big_pkt->isWrite() && cpu->handleWritePacket())) {
                    main_send_state->fragments[other_index] = NULL;
                }
            } else {
                cpu->_status = DcacheWaitResponse;
                // memory system takes ownership of packet
                cpu->dcache_pkt = NULL;
            }
        }
    } else if (sendTimingReq(tmp)) {
        cpu->_status = DcacheWaitResponse;
        // memory system takes ownership of packet
        cpu->dcache_pkt = NULL;
    }
}

FpgaCPU::IprEvent::IprEvent(Packet *_pkt, FpgaCPU *_cpu,
    Tick t)
    : pkt(_pkt), cpu(_cpu)
{
//cout << "FpgaCPU::IprEvent::IprEvent(Packet *_pkt, FpgaCPU *_cpu,"  << endl;
    cpu->schedule(this, t);
}

void
FpgaCPU::IprEvent::process()
{
//cout << "FpgaCPU::IprEvent::process()"  << endl;
    cpu->completeDataAccess(pkt);
}

const char *
FpgaCPU::IprEvent::description() const
{
    return "Timing Simple CPU Delay IPR event";
}


void
FpgaCPU::printAddr(Addr a)
{
    dcachePort.printAddr(a);
}
////////////////////////////////////////////////////////////////////////

Tick
FpgaCPU::recvAtomic(PacketPtr pkt)
{
	Addr offset = (pkt->getAddr() - ControlAddr)>>3;
	uint64_t reg = offset;
	uint64_t val = htog(getFPGAReg(reg));
	if (pkt->isRead())
	{
		pkt->setData((uint8_t *)&val);
		pkt->makeResponse();
	}
	else if (pkt->isWrite())
	{
		pkt->writeData((uint8_t *)&val);
		setFPGAReg(reg,val);
		pkt->makeResponse();
	}
	return latency;
}

void //TODO
FpgaCPU::recvFunctional(PacketPtr pkt)
{
	recvAtomic(pkt);
}

bool
FpgaCPU::recvTimingReq(PacketPtr pkt)
{
	if (_status == BaseSimpleCPU::Idle)
		activateContext(0);
    for (int x = 0; x < pendingDelete.size(); x++)
        delete pendingDelete[x];
    pendingDelete.clear();

    if (retryReq)
        return false;

    if (isBusy) {
        retryReq = true;
        return false;
    }

    pkt->headerDelay = pkt->payloadDelay = 0;

    if (pkt->isRead() || pkt->isWrite()) {

        Tick duration = latency;
        if (duration != 0) {
            schedule(releaseEvent, curTick() + duration);
            isBusy = true;
        }
    }

    bool needsResponse = pkt->needsResponse();
    recvAtomic(pkt);
    if (needsResponse) {
        assert(pkt->isResponse());
        packetQueue.emplace_back(DeferredPacket(pkt, curTick() + latency + pkt->headerDelay + pkt->payloadDelay));
        if (!retryResp && !dequeueEvent.scheduled())
            schedule(dequeueEvent, packetQueue.back().tick);
    } else {
        pendingDelete.push_back(pkt);
    }

    return true;
}

void
FpgaCPU::release()
{
    assert(isBusy);
    isBusy = false;
    if (retryReq) {
        retryReq = false;
        controlPort.sendRetryReq();
    }
}

void
FpgaCPU::dequeue()
{
    assert(!packetQueue.empty());
    DeferredPacket deferred_pkt = packetQueue.front();

    retryResp = !controlPort.sendTimingResp(deferred_pkt.pkt);

    if (!retryResp) {
        packetQueue.pop_front();

        if (!packetQueue.empty()) {
            reschedule(dequeueEvent,
                       std::max(packetQueue.front().tick, curTick()), true);
        }
    }
}

void
FpgaCPU::recvRespRetry()
{
    assert(retryResp);
    dequeue();
}

BaseSlavePort &
FpgaCPU::getSlavePort(const std::string &if_name, PortID idx)
{
    if (if_name != "control_port") {
        return MemObject::getSlavePort(if_name, idx);
    } else {
        return controlPort;
    }
}


AddrRangeList
FpgaCPU::FpgaCPUControlPort::getAddrRanges() const
{
	AddrRange range(ControlAddr,ControlAddr+size_control_fpga);
    AddrRangeList ranges;
    ranges.push_back(range);
    return ranges;
}

void
FpgaCPU::setFPGAReg(uint64_t regid, uint64_t val)
{
    switch (regid)
    {
        case 1: ReadBase = val;inputArray[bit_ReadBase] = val; break;
		case 2: WriteBase = val;inputArray[bit_WriteBase] = val; break;
        case 3: 
				{
					bool find = 0;
					for (int i = 0;i<system->threadContexts.size();i++)
						
						{
							LiveProcess* p = (LiveProcess*)(system->threadContexts[i]->getProcessPtr());
							if (p->pid() == val)
							{
								find = 1;
								CurrentThreadID = i; break;
							}
						}
					if (!find) fatal("Can't find the corresponding process.\n");
				//	printf("CurrentThreadID %lu\n",CurrentThreadID);
					break;
				}
        case 4: MemoryRange = val; inputArray[bit_Num_Read]=val;break;
        case 5: MemorySize = val; inputArray[bit_Size_ReadData_Input] = val;break;
        case 6: RunState = val;inputArray[bit_Run] = (val==0); break;
		case 7: Terminate = val;break;
		case 8: OccupyFPGA = val; break;
    }
}

uint64_t
FpgaCPU::getFPGAReg(uint64_t regid)
{
    if  (regid == 1) {return ReadBase;}
	else if (regid == 2) {return WriteBase;}
    else if (regid == 3) {return CurrentThreadID;}
    else if (regid == 4) {return MemoryRange;}
    else if (regid == 5) {return MemorySize;}
    else if (regid == 6) {return RunState;}
	else if (regid == 7) {return Terminate;}
	else if (regid == 8) {return OccupyFPGA;}
    else return 0;
}

Tick
FpgaCPU::FpgaCPUControlPort::recvAtomic(PacketPtr pkt)
{
    return cpu->recvAtomic(pkt);
}

void
FpgaCPU::FpgaCPUControlPort::recvFunctional(PacketPtr pkt)
{
    cpu->recvFunctional(pkt);
}

bool
FpgaCPU::FpgaCPUControlPort::recvTimingReq(PacketPtr pkt)
{
    return cpu->recvTimingReq(pkt);
}

void
FpgaCPU::FpgaCPUControlPort::recvRespRetry()
{
    cpu->recvRespRetry();
}

////////////////////////////////////////////////////////////////////////
//
//  FpgaCPU Simulation Object
//
FpgaCPU *
FpgaCPUParams::create()
{
//cout << "FpgaCPUParams::create()"  << endl;
    numThreads = 1;
	printf("workload.size()--%d\n",(int)workload.size());
    return new FpgaCPU(this);
}
